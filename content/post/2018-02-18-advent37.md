---
title: OS自作入門 -Advent37-
date: 2018-02-18T00:00:00+09:00
draft: false
tags:
- トリログ
- Tech
- Advent
- 挑戦
description: 今回は12step目です！外部割込みを実装します。
keywords:
- 株式会社ワタリドリ
- wataridori inc.
- blog
- wtrdr
isCJKLanguage: true
# thumbnailImage: /img/2017-12-10/1.png
# thumbnailImagePosition: left
---

## Step12 外部割込みを実装する

ようやく最終stepにきた。長い道のりだった。最後のテーマは外部割込み。シリアルから1文字受信割込みと、コマンド応答スレッドを作成する。

### 割込みとスレッド

step6とstep8で利用した`gets()`はビジーループによりシリアルの受信待ちをしている。そのため常にCPUがシリアルコントローラのレジスタを監視しており利用効率がよくない。step7のように割込みベースにするのが良い。しかし、step7ではシリアル受信割込みハンドラの内部でコマンド応答処理を行なっており、重たい処理があると応答性を下げるので良くない。 *割込み処理は極力短く書く* という鉄則がある。

なので、受信文字から処理へ繋げて処理の部分を別なスレッドで行うという方針を取った方が良い。

#### シリアル受信割込み

1. シリアル受信割込みハンドラでは受信文字からメッセージによりコマンド応答スレッドに送信。
1. コマンド応答スレッドは、メッセージを受信してコマンドとして解釈し処理をを小なう。

こうすることによりシリアル受信の割込みハンドラが受信・割込みのクリア・メッセージ送信のシンプルな処理だけで済む。

#### シリアル送信割込み

シリアル送信割込みが発生するのは「1文字送信を行った時に、その送信処理が完了して次の文字の送信が可能になった時」である。`serial_is_send_enable()`で送信可能かどうかのチェックを行っているが、ビジーループによる待ち合わせである。これはSCI（シリアルコミュニケーションインターフェース）の総員バッファが1文字しか格納できない構造であるため、前の文字の出力が完了するまで次の文字が入ってくると問題となるためである。しかしこれもまた無駄な処理であり、このビジーループの間に他の処理を行うことができるはず。それを回避するために以下のような実装にする。

1. シリアル送信の割込みハンドラとシリアル送信スレッドを作成
1. シリアル送信スレッドは送信要求を受けたら、送信バッファに送信する文字列を書き込み先頭の1文字を送信。割込み待ちにする。
1. 送信完了したら、シリアル送信割込みを発生させ割込みハンドラで未送信の文字が残っているなら送信する。
1. 送信が終わるまで繰り返し。

と言う感じに送信用のバッファを作って、それを中継して割込み => 送信の処理を分離しておくような感じ。受付は都度行い、暇な時に処理を行うみたいな。

「シリアル送信スレッド」を「コンソール・ドライバ・スレッド」として実装する。

#### 非タスク・コンテキスト

割込み中にシステム・コールを行うと、割込み時に動作していたスレッド（カレントスレッド）のコンテキスト情報が割込み中のシステム・コールにより破壊されてしまい、スレッドが正常に動作再開できなくなってしまう。そのため *割込み処理は中断と再開ができない* 。こういった状態を **非タスク・コンテキスト** と呼ぶ。なので、割込み処理は非タスク・コンテキスト、スレッドの状態はタスク・コンテキストと呼ばれている。そのため割込みハンドラからシステム・コールを呼び出すことはできない。

#### サービス・コール

割込み処理は割込みハンドラから呼ばれているため、システム・コールが処理される場合とコンテキストは同一であるため、OS内部が持つシステム・コールの処理関数をそのまま呼んでも実は実害がないとか。。。なので今回は非タスク・コンテキスト向けのサービスとして、**サービス・コール**を実装する。

KOZOSでは割込み処理中は割込み禁止になっているので関数の再入は考慮する必要はない。注意点としては、タスク・コンテキストであるスレッドからはサービス・コールは利用してはならないということだ。サービス・コールは基本として割込みハンドラ向けに提供するサービス関数である。

以下のような関数を用意する（kz_xxxからkxに名前を置き換えたものを用意する）

- kx_wakeup
    割込みが入るまでスリープして、割込みハンドラからウェイクアップすることで動作開始するようなスレッドを作成したい場合に利用。
- kx_send
    割込みハンドラから処理スレッドに受信データを渡したい場合に利用。
- kx_kmalloc, kx_kmfree
    割込みハンドラから処理スレッドにデータを渡す際にメモリ獲得が必要な場合がありその際に利用。

#### 排他

シリアル送信時の動作で考えなくてはいけないことがある。それは送信バッファの取り扱いである。シリアル送信の割込み処理と、コンソール・ドライバ・スレッドの両者から触られる可能性があるため、例えばコンソール・ドライバ・スレッドから大量の文字をバッファにコピーしている最中に、送信割込みが入り1文字送信することにより送信バッファの内容が変化し、コピー処理が再開されて変化した後のバッファに上乗せされる形となるとおかしな処理結果となる可能性がある。

そのためstep11で出てきた送信バッファに対する *ロック処理* を施しスレッド間で動機を取るようにする。そのため、「ロック」「ロック解除」「ロック中の待ち合わせ」を行うようなサービスをシステム・コールとしてOSに実装する必要がある。

が、このような同期処理は、シリアル割込みへの適用は不的確らしい。前述の通り、割込み処理は中断と再開はできないので、「待ち合わせる」と言う動作は基本的にできないためである。

なので今回は排他の最も簡単な実現方法として、割込み禁止を利用することで実現する。

#### 割込みの管理

KOZOSではOSの内部で割込みハンドラの配列を持っていて、ここの登録されている関数を実行している。

```c
static kz_hanlder_t handlers[SOFTVEC_TYPE_NUM]; // ここで定義されている

if(hanlders[type])
  handlers(type)(); // これで実行

setintr(SOFTVEC_TYPE_SYSCALL, syscall_intr); // システム・コールハンドラ登録
setintr(SOFTVEC_TYPE_SOFTERR, softerr_intr); // エラー処理用のハンドラ登録
```

今回はここに、割込みハンドラを自由に登録できるようにOSのサービスとして公開、利用できるようにする。

このような仕様になる。

```c
int kz_setintr(softvec_type_t type, kz_hanlder_t handler);
```

#### UML

結構複雑な動きなのでUMLがあったので転用させてもらおう。

{{< image classes="fancybox fig-100 center clear" src="/img/2018-02-18/uml.png" >}}

### 実装

ということで実装。以下のファイルを追加・修正する。

- consdrv.h, consdrv.c（新規）
    コンソールドライバスレッド
- command.c（新規）
    コマンドスレッド
- defines.h（修正）
- syscall.h, syscall.c（修正）
- kozos.h, kozos.c（修正）
- main.c（修正）
- Makefile（修正）

#### メッセージIDの定義

[defines.h](https://github.com/wtrdr/os-advent2017/blob/master/12/os/defines.h)にメッセージIDを定義。

```c
typedef enum {
  MSGBOX_ID_CONSINPUT = 0,
  MSGBOX_ID_CONSOUTPUT,
  MSGBOX_ID_NUM
} kz_msgbox_id_t;
```

#### システム・コールとサービス・コールの追加

[syscall.h](https://github.com/wtrdr/os-advent2017/blob/master/12/os/syscall.h)を修正。

`kz_setintr()`のためのシステム・コール番号である`KZ_SYSCALL_TYPE_SETINTR`とパラメータ領域を加える。

[syscall.c](https://github.com/wtrdr/os-advent2017/blob/master/12/os/syscall.c)を修正。

システム・コールの本体である`kz_setintr()`を追加。
`kx_wakeup`, `kx_send`, `kx_kmalloc`, `kx_kmfree`を追加。kxシリーズの違いは`kz_syscall`の代わりに`kz_srvcall`を使ってサービス・コールを呼び出している。

#### システム・コールとサービス・コールの実装

[kozos.h](https://github.com/wtrdr/os-advent2017/blob/master/12/os/kozos.h)を修正。

システム・コールとして`kz_setintr`、サービスコールとして`kx_wakeup`, `kx_send`, `kx_kmalloc`, `kx_kmfree`の4つのプロトタイプ宣言を追加。サービス・コールを実際に発行する関数としての`kz_srvcall`の追加。システム・タスクとして `consdrv_main`、ユーザ・タスクとして`command_main`のプロトタイプ宣言の追加。

[kozos.c](https://github.com/wtrdr/os-advent2017/blob/master/12/os/kozos.c)を修正。

割込みハンドラの登録を行う。もともとあった`setintr()`という関数を少し変更を食わせてユーザ側から操作できるようにした。`thread_setintr()`という名称に変更。これは`softvec_setintr()`によりソフトウェア・割込みベクタにKOZOSの割込み処理の受け口である`thread_intr()`を登録している。

`call_functions`に

```
case KZ_SYSCALL_TYPE_SETINTR:
  p->un.setintr.ret = thread_setintr(p->un.setintr.type, p->un.setintr.handler);
  break;
```

を追加。（書籍にはこの`switch..case..`のリファクタの方法も載っている）

`srvcall_proc`（サービス・コールの呼び出し）も追加する。`syscall_proc`との違いは、current（カレントスレッド）の取り扱いで、処理内部に`current`の状態を使っている箇所があるため、誤動作する可能性がある。なので`srvcall_proc`では`current=NULL`としている。

`kz_start`でハンドラの登録に`thread_setintr`を利用するように修正。

最後にサービス・コールの呼び出しのための関数`kz_srvcall`を追加。

#### コンソール・ドライバ・スレッド

KOZOSではデバイス・ドライバをOSのカーネルに内包せず、独立したスレッドとして実装する。コンソールへの出力はコンソール・ドライバ・スレッドへメッセージを送信することにより行うようにする。今回は`u`という文字を受信したら初期化、`wXXX`という文字を受信したらXXXという文字列を出力するように実装する。ここでの`u`、`w`をコマンドと呼ぶことにする。

[consdrv.h](https://github.com/wtrdr/os-advent2017/blob/master/12/os/consdrv.h)を追加する。

コンソールの個数と、二種類のコマンドのを定義する。

[consdrv.c](https://github.com/wtrdr/os-advent2017/blob/master/12/os/consdrv.c)を追加する。

`consreg[]`というコンソール管理用の構造体を定義。内部には送受信用のバッファを備える。

#### シリアル送信と割込みハンドラ

[consdrv.c](https://github.com/wtrdr/os-advent2017/blob/master/12/os/consdrv.c)に送信処理部分を追加する。

文字送信用の`send_char`と文字列送信用の`send_string`を実装。

割込みハンドラを追加する。`consdrv_intr`がシリアルの割込みハンドラとして登録される。内部で受信と送信を分岐させてる。シリアルの送信/受信割込みの状態をチェックし、割込み発生している場合には`consdrv_intrproc`を呼び出す。受信処理の特徴は、受信バッファの内容をコピーし`kx_send`によって`MSGBOX_ID_CONSINPUT`のメッセージボックスに送信している。これは割込みの延長で行われているためサービス・コールを利用した形となっている。送信処理の特徴は、ビジーループではなく最初の1文字目以降の後続の文字列は割込みを発生させて終端まで出力するような形となっている。

#### コマンド処理

[consdrv.c](https://github.com/wtrdr/os-advent2017/blob/master/12/os/consdrv.c)に`u`と`w`に対するコマンドの処理を追加。

`CONSDRV_CMD_USE`(`u`)を受けたら初期化を行う。`CONSDRV_CMD_WRITE`(`w`)を受けたら送信処理を行う。`send_string`は割込み禁止にする必要があるため`INTR_DISABLE`と`INTR_ENABLE`で囲んでおく。このため`send_string`を実行している最中には送信割込みが入ることはない。これは送信バッファの排他処理を保証する必要があるためである。`send_char`を呼ばれると`send_buf`の内容を書き換えてしまうのでそのための対処。

#### コンソール・ドライバ・スレッドのメイン関数

[consdrv.c](https://github.com/wtrdr/os-advent2017/blob/master/12/os/consdrv.c)に`condrv_main`関数を追加。

構造体の初期化（`consdrv_init`）
割込みハンドラの登録（`kz_setintr(SOFTVEC_TYPE_SERINTR...)`）

を行い、メインループに入る。

メインループでは、`kz_recv`で他のスレッドからコマンドの要求を待ち、`consdrv_command`でコマンド処理を実行する。

#### コマンド・スレッド

[command.c](https://github.com/wtrdr/os-advent2017/blob/master/12/os/command.c)を追加。

コンソールを初期化するための`send_use`コマンド。コンソールへの文字列出力のための`send_write`を実装。どちらもコンソール・ドライバ・スレッドに対してコマンドを送信することによって処理を実行している。

コマンドのメイン関数である`command_main`を実装。

まず、`send_use`を呼びコンソール・ドライバ・スレッドの初期化。
メインループに入り、`kz_recv`によってコンソール・ドライバ・スレッドからメッセージ受信を待つ。
コンソール・ドライバ・スレッドの割込みハンドラから`MSGBOX_ID_CONSINPUT`宛に受信文字列が送信される。
受信文字列の最初が`echo`の場合には後続の文字列を出力する。それ以外は`unknown`。
文字列出力は`send_write`を呼び出し、コンソール・ドライバ・スレッドに`CONSDRV_CMD_WRITE`のメッセージが送信される。

[main.c](https://github.com/wtrdr/os-advent2017/blob/master/12/os/main.c)で起動するスレッドを修正。
[Makefile](https://github.com/wtrdr/os-advent2017/blob/master/12/os/Makefile)にコンパイル対象を追加。

### 実行

```sh
kzload> run
starting from entry point: ffc020
kozos boot succeed!
command> echo aaa
 aaa
command>
```

できた。

---------------------------------------

ようやく全部終わった！最後の最後で[serial.c](https://github.com/wtrdr/os-advent2017/commit/9e00bdb6890e5b9d2598d13cb668749dcddedf28#diff-7f98b47ca03d7b34528f75b4b24f78bb)がミスってたのに気づいて直した。割込みでシリアルの状態を判定するってのが無かったから気づかなかったのか。だいぶ時間使ってしまった。

さて、これでOSとしての「CPU」「メモリ」「I/O」「割込み」という大きな仕組みを実装することができた。まだまだ知識レベルが低いけど、やる前よりだいぶ言葉の定義とかどんな感じなのかとか掴めてよかったなー。あとは時間のあるときに最初から流し読みだけしておこう。

なんかOS周りのワードとか実装イメージに困ったら戻って来れそうな良書だったと思う。さて、そろそろ勉強の時間をやめて新しくなんか作る方にシフトしようかな。今年のアドベントカレンダーはCPUの作り方でも良いかも知れん。新しい言語を扱ってみるってのもありだなぁ。

**以上でアドベントカレンダー2017はおしまい！！！**
ソースコードは[こちらから](https://github.com/wtrdr/os-advent2017)。
